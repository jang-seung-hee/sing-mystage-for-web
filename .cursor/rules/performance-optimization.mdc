---
globs: *.tsx,*.jsx,*.ts,*.js
description: 성능 최적화 및 메모리 관리 표준
---

# 성능 최적화 표준

## React 성능 최적화

### 메모이제이션 전략
```typescript
// React.memo로 불필요한 리렌더링 방지
const VideoCard = React.memo<VideoCardProps>(({ video, onSelect, isSelected }) => {
  return (
    <div 
      className={`cursor-pointer transition-all duration-200 ${
        isSelected ? 'ring-2 ring-neon-cyan' : ''
      }`}
      onClick={() => onSelect(video.id)}
    >
      <img src={video.thumbnail} alt={video.title} />
      <h3>{video.title}</h3>
    </div>
  );
});

// useMemo로 계산 비용이 큰 값 캐싱
const expensiveCalculation = useMemo(() => {
  return searchResults
    .filter(result => result.duration && result.duration !== '0:00')
    .sort((a, b) => new Date(b.publishedAt).getTime() - new Date(a.publishedAt).getTime());
}, [searchResults]);

// useCallback으로 함수 메모이제이션
const handleVideoSelect = useCallback((videoId: string) => {
  setCurrentVideo(videoId);
  setIsPlaying(true);
  // 최근 재생 목록에 추가
  addToRecentPlayed(videoId);
}, [setCurrentVideo, setIsPlaying, addToRecentPlayed]);
```

### 컴포넌트 지연 로딩
```typescript
// Lazy Loading으로 번들 크기 최적화
const SidePanel = React.lazy(() => import('../components/SidePanel/SidePanel'));
const VideoPanel = React.lazy(() => import('../components/VideoPanel/VideoPanel'));
const FavoritesModal = React.lazy(() => import('../components/Favorites/FavoritesModal'));

// Suspense로 로딩 상태 처리
<Suspense fallback={<LoadingSpinner />}>
  <SidePanel />
</Suspense>
```

### 가상화 (Virtualization)
```typescript
// 긴 목록에 대한 가상 스크롤링
import { FixedSizeList as List } from 'react-window';

const VirtualizedVideoList = ({ videos, onVideoSelect }) => {
  const Row = ({ index, style }) => (
    <div style={style}>
      <VideoCard 
        video={videos[index]} 
        onSelect={onVideoSelect}
      />
    </div>
  );

  return (
    <List
      height={600}
      itemCount={videos.length}
      itemSize={120}
      width="100%"
    >
      {Row}
    </List>
  );
};
```

## 이미지 최적화

### 지연 로딩 및 최적화
```typescript
// 이미지 지연 로딩
const LazyImage = ({ src, alt, className, ...props }) => {
  const [isLoaded, setIsLoaded] = useState(false);
  const [isInView, setIsInView] = useState(false);
  const imgRef = useRef<HTMLImageElement>(null);

  useEffect(() => {
    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting) {
          setIsInView(true);
          observer.disconnect();
        }
      },
      { threshold: 0.1 }
    );

    if (imgRef.current) {
      observer.observe(imgRef.current);
    }

    return () => observer.disconnect();
  }, []);

  return (
    <div ref={imgRef} className={className} {...props}>
      {isInView && (
        <img
          src={src}
          alt={alt}
          onLoad={() => setIsLoaded(true)}
          className={`transition-opacity duration-300 ${
            isLoaded ? 'opacity-100' : 'opacity-0'
          }`}
        />
      )}
    </div>
  );
};
```

### 이미지 크기 최적화
```typescript
// YouTube 썸네일 최적화
const getOptimizedThumbnail = (url: string, size: 'default' | 'medium' | 'high' = 'medium') => {
  // YouTube 썸네일 URL 파라미터 조정
  const sizeMap = {
    default: 'default.jpg',
    medium: 'mqdefault.jpg',
    high: 'hqdefault.jpg'
  };
  
  return url.replace(/\/[^\/]+\.jpg$/, `/${sizeMap[size]}`);
};
```

## 메모리 관리

### 메모리 누수 방지
```typescript
// 컴포넌트 언마운트 시 정리
useEffect(() => {
  const handleKeyPress = (event: KeyboardEvent) => {
    if (event.key === 'Escape') {
      onClose();
    }
  };

  window.addEventListener('keydown', handleKeyPress);
  
  // 클린업 함수로 이벤트 리스너 제거
  return () => {
    window.removeEventListener('keydown', handleKeyPress);
  };
}, [onClose]);

// AbortController로 요청 취소
useEffect(() => {
  const abortController = new AbortController();
  
  const fetchData = async () => {
    try {
      const response = await fetch('/api/data', {
        signal: abortController.signal
      });
      const data = await response.json();
      setData(data);
    } catch (error) {
      if (error.name !== 'AbortError') {
        console.error('데이터 로딩 실패:', error);
      }
    }
  };

  fetchData();

  return () => {
    abortController.abort();
  };
}, []);
```

### 상태 최적화
```typescript
// 상태 업데이트 최적화
const updateVideoList = useCallback((newVideo: Video) => {
  setVideoList(prevList => {
    // 중복 제거 및 정렬
    const filtered = prevList.filter(video => video.id !== newVideo.id);
    return [newVideo, ...filtered].slice(0, 50); // 최대 50개 유지
  });
}, []);

// 상태 분할로 리렌더링 최소화
const [playerState, setPlayerState] = useState({
  isPlaying: false,
  currentTime: 0,
  duration: 0
});

// 개별 상태로 분할
const [isPlaying, setIsPlaying] = useState(false);
const [currentTime, setCurrentTime] = useState(0);
const [duration, setDuration] = useState(0);
```

## 번들 최적화

### 코드 스플리팅
```typescript
// 라우트 기반 코드 스플리팅
const MainPage = React.lazy(() => import('../pages/MainPage'));
const TestPage = React.lazy(() => import('../pages/TestPage'));

// 기능 기반 코드 스플리팅
const YouTubePlayer = React.lazy(() => import('../components/Player/YouTubeIframePlayer'));
const SearchResults = React.lazy(() => import('../components/Search/SearchResults'));
```

### 트리 셰이킹
```typescript
// 필요한 함수만 import
import { searchYouTube } from '../services/youtubeApi';
// 전체 모듈 import 금지
// import * as youtubeApi from '../services/youtubeApi';

// 동적 import로 조건부 로딩
const loadAdvancedFeatures = async () => {
  const { AdvancedPlayer } = await import('../components/Player/AdvancedPlayer');
  return AdvancedPlayer;
};
```

## 네트워크 최적화

### 요청 최적화
```typescript
// 요청 캐싱
const useYouTubeSearch = () => {
  const [cache, setCache] = useState<Map<string, YouTubeSearchResult[]>>(new Map());

  const searchVideos = useCallback(async (query: string) => {
    // 캐시 확인
    if (cache.has(query)) {
      return cache.get(query)!;
    }

    // API 호출
    const results = await searchYouTube(query);
    
    // 캐시에 저장 (최대 100개 쿼리 유지)
    setCache(prev => {
      const newCache = new Map(prev);
      if (newCache.size >= 100) {
        const firstKey = newCache.keys().next().value;
        newCache.delete(firstKey);
      }
      newCache.set(query, results);
      return newCache;
    });

    return results;
  }, [cache]);

  return { searchVideos };
};

// 요청 디바운싱
const useDebounce = (value: string, delay: number) => {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
};
```

### 프리로딩
```typescript
// 중요한 리소스 프리로딩
useEffect(() => {
  // 다음에 사용할 가능성이 높은 이미지 프리로딩
  const preloadImages = (urls: string[]) => {
    urls.forEach(url => {
      const img = new Image();
      img.src = url;
    });
  };

  if (searchResults.length > 0) {
    const thumbnailUrls = searchResults
      .slice(0, 5)
      .map(result => getOptimizedThumbnail(result.thumbnail));
    preloadImages(thumbnailUrls);
  }
}, [searchResults]);
```

## 성능 모니터링

### Web Vitals 측정
```typescript
// 성능 메트릭 수집
import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';

const reportWebVitals = (onPerfEntry?: (metric: any) => void) => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    getCLS(onPerfEntry);
    getFID(onPerfEntry);
    getFCP(onPerfEntry);
    getLCP(onPerfEntry);
    getTTFB(onPerfEntry);
  }
};

// 성능 측정
reportWebVitals((metric) => {
  console.log('Web Vitals:', metric);
  // Sentry 등으로 전송
});
```

## 금지 사항

### ❌ 성능 저해 요소
- 모든 컴포넌트에 React.memo 사용 (불필요한 경우)
- useMemo/useCallback 남용 (의존성 배열이 자주 변경되는 경우)
- 인라인 객체/함수 생성으로 인한 리렌더링
- 큰 이미지 파일을 압축 없이 사용
- 메모리 누수 가능한 이벤트 리스너 미정리

### ❌ 번들 크기 증가 요소
- 사용하지 않는 라이브러리 import
- 전체 모듈 import (* as)
- 불필요한 polyfill 포함
- 중복 라이브러리 설치