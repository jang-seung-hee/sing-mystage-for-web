---
alwaysApply: true
description: 보안 표준 및 민감정보 관리 정책
---

# 보안 표준 및 민감정보 관리

## 환경 변수 및 비밀정보 관리

### 환경 변수 설정
```typescript
// 환경 변수 타입 정의
interface EnvironmentConfig {
  REACT_APP_FIREBASE_API_KEY: string;
  REACT_APP_FIREBASE_AUTH_DOMAIN: string;
  REACT_APP_FIREBASE_PROJECT_ID: string;
  REACT_APP_FIREBASE_STORAGE_BUCKET: string;
  REACT_APP_FIREBASE_MESSAGING_SENDER_ID: string;
  REACT_APP_FIREBASE_APP_ID: string;
  REACT_APP_YOUTUBE_API_KEY: string;
  REACT_APP_USE_FUNCTIONS_EMULATOR: string;
}

// 환경 변수 검증
const validateEnvironmentConfig = (): EnvironmentConfig => {
  const requiredVars = [
    'REACT_APP_FIREBASE_API_KEY',
    'REACT_APP_FIREBASE_AUTH_DOMAIN',
    'REACT_APP_FIREBASE_PROJECT_ID',
    'REACT_APP_YOUTUBE_API_KEY'
  ];

  for (const varName of requiredVars) {
    if (!process.env[varName]) {
      throw new Error(`필수 환경 변수 ${varName}가 설정되지 않았습니다`);
    }
  }

  return process.env as EnvironmentConfig;
};
```

### .env 파일 관리
```bash
# .env.example (템플릿 파일)
REACT_APP_FIREBASE_API_KEY=your_api_key_here
REACT_APP_FIREBASE_AUTH_DOMAIN=your_project.firebaseapp.com
REACT_APP_FIREBASE_PROJECT_ID=your_project_id
REACT_APP_FIREBASE_STORAGE_BUCKET=your_project.appspot.com
REACT_APP_FIREBASE_MESSAGING_SENDER_ID=your_sender_id
REACT_APP_FIREBASE_APP_ID=your_app_id
REACT_APP_YOUTUBE_API_KEY=your_youtube_api_key
REACT_APP_USE_FUNCTIONS_EMULATOR=false

# .env (실제 파일 - Git에 커밋 금지)
# 위 템플릿을 복사하여 실제 값으로 채우기
```

## GitHub 업로드 금지 파일

### 절대 금지 파일 패턴
```gitignore
# 압축/배포 아카이브 - 모두 금지
*.zip
*.rar
*.7z
*.tar
*.gz
*.tar.gz
*.tar.bz2

# API 등록/자격 증명 파일 - 모두 금지
google-services.json
serviceAccountKey.json
firebase-adminsdk-*.json
client_secret*.json
*.p12
*.pem
*.pfx
*.keystore
AppleAuthKey_*.p8
aws_credentials
*.ovpn
postman_environment*.json

# 환경 변수 파일
.env
.env.local
.env.production
.env.staging

# 로그 파일
*.log
logs/
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# 빌드 아티팩트
build/
dist/
.next/
out/

# 의존성
node_modules/
.pnp
.pnp.js

# IDE 설정
.vscode/settings.json
.idea/
*.swp
*.swo
```

### Pre-commit 훅 설정
```bash
#!/bin/bash
# .git/hooks/pre-commit
set -e

echo "보안 파일 검사 중..."

# 금지된 파일 패턴 검사
blocked_patterns='\.zip$|\.rar$|\.7z$|\.tar$|\.gz$|google-services\.json$|serviceAccountKey\.json$|firebase-adminsdk-.*\.json$|client_secret.*\.json$|\.p12$|\.pem$|\.pfx$|\.keystore$|AppleAuthKey_.*\.p8$|aws_credentials$|\.ovpn$|postman_environment.*\.json$|\.env$'

changed=$(git diff --cached --name-only)

if echo "$changed" | grep -E "$blocked_patterns" >/dev/null; then
  echo "
[BLOCK] 보안 위험 파일이 스테이징되었습니다.
다음 파일들을 .gitignore에 추가하거나 시크릿 매니저로 이전하세요." >&2
  echo "$changed" | grep -E "$blocked_patterns" >&2
  exit 1
fi

echo "✅ 보안 검사 통과"
```

## Firebase 보안 규칙

### Firestore 보안 규칙
```javascript
// firestore.rules
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // 인증된 사용자만 접근 가능
    match /favorites/{document} {
      allow read, write: if request.auth != null && request.auth.uid == resource.data.userId;
    }
    
    // 사용자 설정은 소유자만 접근
    match /userSettings/{document} {
      allow read, write: if request.auth != null && request.auth.uid == document;
    }
    
    // 공유 즐겨찾기는 읽기만 허용
    match /sharedFavorites/{document} {
      allow read: if request.auth != null;
      allow write: if request.auth != null && request.auth.uid == resource.data.ownerId;
    }
    
    // 최근 재생 목록은 소유자만 접근
    match /recentPlayed/{document} {
      allow read, write: if request.auth != null && request.auth.uid == resource.data.userId;
    }
  }
}
```

### Firebase Functions 보안
```javascript
// functions/index.js
const functions = require('firebase-functions');
const admin = require('firebase-admin');

// YouTube API 호출 함수
exports.searchYouTube = functions.region('asia-northeast3').https.onCall(async (data, context) => {
  // 인증 확인 필수
  if (!context.auth) {
    throw new functions.https.HttpsError('unauthenticated', '로그인이 필요합니다.');
  }
  
  // 입력값 검증
  const { query } = data;
  if (!query || typeof query !== 'string' || query.length > 100) {
    throw new functions.https.HttpsError('invalid-argument', '유효하지 않은 검색어입니다.');
  }
  
  // Rate limiting 체크
  const userDoc = await admin.firestore()
    .collection('userSettings')
    .doc(context.auth.uid)
    .get();
    
  const userData = userDoc.data();
  const lastSearchTime = userData?.lastSearchTime || 0;
  const now = Date.now();
  
  if (now - lastSearchTime < 1000) { // 1초 제한
    throw new functions.https.HttpsError('resource-exhausted', '요청이 너무 빈번합니다.');
  }
  
  // 검색 시간 업데이트
  await admin.firestore()
    .collection('userSettings')
    .doc(context.auth.uid)
    .set({
      lastSearchTime: now
    }, { merge: true });
  
  try {
    // YouTube API 호출 로직
    const results = await searchYouTubeAPI(query);
    return { results };
  } catch (error) {
    console.error('YouTube 검색 오류:', error);
    throw new functions.https.HttpsError('internal', '검색 중 오류가 발생했습니다.');
  }
});
```

## 클라이언트 사이드 보안

### 민감정보 하드코딩 금지
```typescript
// ❌ 절대 금지
const API_KEY = 'AIzaSyBxxxxxxxxxxxxxxxxxxxxxxxxxxx'; // 하드코딩 금지
const FIREBASE_CONFIG = {
  apiKey: 'AIzaSyBxxxxxxxxxxxxxxxxxxxxxxxxxxx', // 하드코딩 금지
  // ...
};

// ✅ 올바른 방법
const API_KEY = process.env.REACT_APP_FIREBASE_API_KEY;
const FIREBASE_CONFIG = {
  apiKey: process.env.REACT_APP_FIREBASE_API_KEY,
  authDomain: process.env.REACT_APP_FIREBASE_AUTH_DOMAIN,
  projectId: process.env.REACT_APP_FIREBASE_PROJECT_ID,
  // ...
};
```

### 입력값 검증 및 Sanitization
```typescript
// 사용자 입력 검증
export const validateUserInput = {
  searchQuery: (query: string): boolean => {
    if (!query || typeof query !== 'string') return false;
    if (query.length > 100) return false;
    if (query.trim().length === 0) return false;
    
    // XSS 방지
    const dangerousPatterns = /<script|javascript:|on\w+=/i;
    return !dangerousPatterns.test(query);
  },
  
  videoId: (id: string): boolean => {
    if (!id || typeof id !== 'string') return false;
    // YouTube 비디오 ID 형식 검증
    const youtubeIdPattern = /^[a-zA-Z0-9_-]{11}$/;
    return youtubeIdPattern.test(id);
  }
};

// 입력값 Sanitization
export const sanitizeInput = (input: string): string => {
  return input
    .trim()
    .replace(/[<>]/g, '') // HTML 태그 제거
    .substring(0, 100); // 길이 제한
};
```

## 에러 처리 및 로깅

### 보안을 고려한 에러 처리
```typescript
// 에러 메시지에서 민감정보 제거
export const handleFirebaseError = (error: unknown): never => {
  console.error('Firebase 오류:', error); // 개발 환경에서만 로그
  
  if (error && typeof error === 'object' && 'code' in error) {
    const firebaseError = error as any;
    
    // 사용자에게는 일반적인 메시지만 전달
    switch (firebaseError.code) {
      case 'functions/unavailable':
        throw new Error('서버가 일시적으로 사용할 수 없습니다.');
      case 'functions/invalid-argument':
        throw new Error('잘못된 요청입니다.');
      case 'functions/permission-denied':
        throw new Error('권한이 없습니다.');
      default:
        throw new Error('예상치 못한 오류가 발생했습니다.');
    }
  }
  
  throw new Error('네트워크 오류가 발생했습니다.');
};
```

## 배포 환경 보안

### Netlify 환경 변수 설정
```bash
# Netlify 대시보드에서 설정
REACT_APP_FIREBASE_API_KEY=production_api_key
REACT_APP_FIREBASE_AUTH_DOMAIN=production_domain
REACT_APP_FIREBASE_PROJECT_ID=production_project_id
REACT_APP_YOUTUBE_API_KEY=production_youtube_key
REACT_APP_USE_FUNCTIONS_EMULATOR=false
```

### CI/CD 보안 체크
```yaml
# .github/workflows/security-check.yml
name: Security Check
on: [push, pull_request]

jobs:
  security-check:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      
      - name: Check for sensitive files
        run: |
          if find . -name "*.json" -exec grep -l "apiKey\|secret\|password" {} \; | grep -v node_modules; then
            echo "❌ 민감정보가 포함된 파일 발견"
            exit 1
          fi
          
      - name: Check for hardcoded secrets
        run: |
          if grep -r "AIzaSy" --exclude-dir=node_modules --exclude-dir=.git .; then
            echo "❌ 하드코딩된 API 키 발견"
            exit 1
          fi
```

## 금지 사항

### ❌ 절대 금지
- API 키나 비밀번호를 코드에 하드코딩
- 압축 파일이나 인증서 파일을 Git에 커밋
- 환경 변수 파일(.env)을 Git에 커밋
- 사용자에게 상세한 에러 정보 노출
- 클라이언트에서 직접 YouTube API 호출
- Firebase 보안 규칙 없이 Firestore 사용

### ❌ 보안 위반
- 입력값 검증 없이 사용자 데이터 처리
- XSS 공격을 방지하지 않은 사용자 입력 처리
- Rate limiting 없는 API 호출
- 인증 없이 민감한 데이터 접근 허용